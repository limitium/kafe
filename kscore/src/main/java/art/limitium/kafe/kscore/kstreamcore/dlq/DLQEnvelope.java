package art.limitium.kafe.kscore.kstreamcore.dlq;

import org.apache.kafka.common.serialization.Deserializer;
import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.common.serialization.Serializer;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

public record DLQEnvelope(
        long id, //generated by Sequencer

        String message, //exception.getMessage()
        String stacktrace, //exception.getStacktrace()

        String payloadClass, //payload fqn class
        String payloadBodyJSON, //payload converted to JSON

        String sourceTopic, //Topic name of the current input record
        int sourcePartition, //kafka partition of the current input record
        long sourceOffset, //Offset of the current input record

        String exceptionClass, //Custom DLQException should be used
        String exceptionKey, //DLQException.key
        String exceptionSubKey, //DLQException.subkey, optional
        long failedAt // context.currentStreamTimeMs() - timestam of broken record coming into system
) {
    public static DLQEnvelope.DLQEnvelopeSerde DLQEnvelopeSerde() {
        return new DLQEnvelope.DLQEnvelopeSerde();
    }

    public static class DLQEnvelopeSerde implements Serde<DLQEnvelope> {

        @Override
        public Serializer<DLQEnvelope> serializer() {
            return new Serializer<DLQEnvelope>() {
                @Override
                public byte[] serialize(String topic, DLQEnvelope envelope) {
                    int fixFieldsLength =
                            3 * 8   //longs
                                    + 4     //int
                                    + 4 * 8 //strings
                            ;

                    byte[] messageBytes = envelope.message != null ? envelope.message.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] stacktraceBytes = envelope.stacktrace != null ? envelope.stacktrace.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] payloadClassBytes = envelope.payloadClass != null ? envelope.payloadClass.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] payloadBodyJSONBytes = envelope.payloadBodyJSON != null ? envelope.payloadBodyJSON.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] sourceTopicBytes = envelope.sourceTopic != null ? envelope.sourceTopic.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] exceptionClassBytes = envelope.exceptionClass != null ? envelope.exceptionClass.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] exceptionKeyBytes = envelope.exceptionKey != null ? envelope.exceptionKey.getBytes(StandardCharsets.UTF_8) : new byte[0];
                    byte[] exceptionSubKeyBytes = envelope.exceptionSubKey != null ? envelope.exceptionSubKey.getBytes(StandardCharsets.UTF_8) : new byte[0];

                    int varyFieldsLength =
                                    + messageBytes.length
                                    + stacktraceBytes.length
                                    + payloadClassBytes.length
                                    + payloadBodyJSONBytes.length
                                    + sourceTopicBytes.length
                                    + exceptionClassBytes.length
                                    + exceptionKeyBytes.length
                                    + exceptionSubKeyBytes.length;


                    ByteBuffer bb = ByteBuffer.allocate(fixFieldsLength + varyFieldsLength);

                    bb.putLong(envelope.id);
                    bb.putInt(envelope.sourcePartition);
                    bb.putLong(envelope.sourceOffset);
                    bb.putLong(envelope.failedAt);

                    putBytes(bb, messageBytes);
                    putBytes(bb, stacktraceBytes);
                    putBytes(bb, payloadClassBytes);
                    putBytes(bb, payloadBodyJSONBytes);
                    putBytes(bb, sourceTopicBytes);
                    putBytes(bb, exceptionClassBytes);
                    putBytes(bb, exceptionKeyBytes);
                    putBytes(bb, exceptionSubKeyBytes);

                    return bb.array();
                }

                private void putBytes(ByteBuffer bb, byte[] bytes) {
                    bb.putInt(bytes.length);
                    bb.put(bytes);
                }
            };
        }

        @Override
        public Deserializer<DLQEnvelope> deserializer() {
            return new Deserializer<>() {
                @Override
                public DLQEnvelope deserialize(String topic, byte[] bytes) {
                    ByteBuffer bb = ByteBuffer.wrap(bytes);

                    long id = bb.getLong();
                    int sourcePartition = bb.getInt();
                    long sourceOffset = bb.getLong();
                    long failedAt = bb.getLong();


                    String message = getString(bb);
                    String stacktrace = getString(bb);
                    String payloadClass = getString(bb);
                    String payloadBodyJSON = getString(bb);
                    String sourceTopic = getString(bb);
                    String exceptionClass = getString(bb);
                    String exceptionKey = getString(bb);
                    String exceptionSubKey = getString(bb);

                    return new DLQEnvelope(
                            id,
                            message,
                            stacktrace,
                            payloadClass,
                            payloadBodyJSON,
                            sourceTopic,
                            sourcePartition,
                            sourceOffset,
                            exceptionClass,
                            exceptionKey,
                            exceptionSubKey,
                            failedAt
                    );
                }

                private String getString(ByteBuffer bb) {
                    byte[] bytes = getBytes(bb);
                    if (bytes == null) {
                        return null;
                    }
                    return new String(bytes, StandardCharsets.UTF_8);
                }

                private byte[] getBytes(ByteBuffer bb) {
                    int strLen = bb.getInt();
                    if (strLen == 0) {
                        return null;
                    }
                    byte[] strBytes = new byte[strLen];
                    bb.get(strBytes, 0, strLen);
                    return strBytes;
                }
            };
        }
    }
}
